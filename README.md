# README — Beaver Multi‑Agent Project

## Report plan
- Executive summary
- Project structure
- Agent workflow and architecture
  - Diagram and roles
  - Decision-making rationale
- State management (critical)
- Data models
  - Dataclass in use
  - Pydantic models recommended
- Validation steps and retry loop (OrderProcessorAgent)
- Tools and functions (commentary)
- Evaluation results (from test_results.csv)
  - Strengths observed
- Improvements and next steps
- How to run (Windows, UV)

## 1) Executive summary
- The project simulates a small paper company operated by a multi‑agent system that:
  - Parses free‑form customer orders.
  - Validates items and requested quantities.
  - Manages inventory and creates transactions (sales and stock orders).
  - Provides quotations.
  - Tracks and enforces business constraints using shared state and a SQLite database.
- Core orchestration is in project_starter.py, with support code in helpers.py (DB + state) and utils.py (tools + reports).
- Batch test runs are summarized in test_results.csv.

## 2) Project structure
- project_starter.py
  - Defines tools: `generate_order_id()`, `extract_request_date()`, `count_order_quantities()`, and `evaluate_purchase_requirement()`.
  - Defines agents:
    - OrderProcessorAgent (parsing order with validation and feedback-driven retry loop).
    - InventoryManagerAgent (stock checks, purchase orders, and sales transactions planning and execution).
    - QuotingAgent (order pricing calculation).
  - Orchestrator: `BeaverOrchestrator.analyze_request()` coordinates the end-to-end flow.
  - Test harness: `run_test_scenarios()` generates test_results.csv.
- helpers.py
  - `paper_supplies`, `generate_sample_inventory()`.
  - `init_database()` that seeds `transactions`, `inventory`, and quote tables.
  - `State` dataclass + `initialize_state()` 
  - `state` and `db_engine` are globally initialized in this script using the above initialization functions on start.
- utils.py
  - Tool-annotated helpers:
    - `create_transaction()`, `get_all_inventory()`, `get_stock_level()`, `get_supplier_delivery_date()`,
      `get_cash_balance()`, `generate_financial_report()`, `search_quote_history()`, `delete_transaction()`.
  - Utilities:
    - `print_rich()`, `pretty_print_financial_report()`, `parse_agent_response()`.
- test_results.csv
  - Per-request results generated by test harness.
- Diagrams
  - flowchart.png, `beaver _ Mermaid Chart-*.png/svg` for visual explanation.

## 3) Agent workflow and architecture

![agentic worflow](./flowchart/beaver_Mermaid_Chart-2025-09-04.png)

### 3.1 Diagram (textual overview)
- Customer Request → Orchestrator
  - a customer request is selected from the test_results.csv file 
  - the state is initialized
- the request is sent to the orchestrator.
  - Orchestrator coordinates the end-to-end flow.
  - the orchestrator.process_request() method is called.
  - the orchestrator calls `count_order_quantities()` to count the number of items in the request and the different quantities to guide the OrderProcessorAgent (naive count).
  - orchestrator calls OrderProcessorAgent passing the request, the `count_order_quantities()` result in the prompt as context and the valid inventory references (stored in the state)
- Orchestrator → OrderProcessorAgent
  - the OrderProcessorAgent returns the bill of materials (BOM), delivery date, a success flag, and a comment as a string. The agent response is parsed using `parse_agent_response()` to extract the success flag, the BOM, comment, order date and delivery date in dictionary for convenience.
  - if the agent identifies invalid materials in the request, fails to offer a valid replacement or extracts an incorrect number of items (double counting or auto-removal of invalid items), it returns a failure flag and a justification comment.
  - A failure success flag **always** leads the orchestrator to return to the customer, decline the order with a comment indicating why (early stopping).
  - **Validation + feedback-driven retry loop**
    - Occasionally, the agent returns a positive success flag but a BOM with incorrect items or number of items. 
    - A Validation + feedback-driven retry loop (max 3 iterations) is implemented in the orchestrator to handle such failed attempts of the orderprocessor agent. 
    - The validation handles the following checks:
        - **check1**: BOM item not in `state.available_items` => invalid item check (e.g. 'A3 paper').
        - **check2**: number of BOM entries > naive count => double counting check (i.e. 'A4 glossy paper' resulted in 'A4 paper' AND 'glossy paper' in the BOM).
        - **check3**: number of BOM entries < naive count =>missed items check due to pruning of invalid items (e.g. the order requests ballons and the agent auto-removes it because it does not belong to the available items).
    - upon validation the process continues or ends with early stopping (see above).


- Valid BOM → InventoryManagerAgent
  - The orchestrator generates a unique order_id then moves to the InventoryManagerAgent.
  - The InventoryManagerAgent processes each line of the BOM.
  - For each line: it validates stock, creates stock orders as needed, creates sales transactions, captures availability dates returned by the `get_supplier_delivery_date()` function. These dates are stored in the `state.availability_date` list. This will be used later to compare with the requested date.
    - all the steps are carried out in the `tool evaluate_purchase_requirement()`.
    - the stock level of an item ordered is checked against the min stock level. if the stock level is planned to be below the min stock level, a stock order is created.
    - The transactions are executed and commited to the database. For each transaction, a unique transaction id is stored in the `state.pending_transactions` list in case the transactions must be rolled back when the order is not confirmed. 
- Valid BOM → QuotingAgent
  - Compute total price from `state.price_list` using the tool `generate_quotation()`. The quotation is returned to the orchestrator.
- Orchestrator finalizes
  - Compare availability date(s) of materials vs order requested date. 
    - If the availability date of the materials is after the requested date, the order is not confirmed and all the order-related transactions are rolled back. 
    - Otherwise the order is confirmed. The custmer is informed in case the supplies can be picked up earlier than requested (e.g. materials are on stock).
  - Confirm or rollback (using `delete_transaction()` and the `state.pending_transactions` list) and respond to the customer with clear guidance.
- the state order-related components will be re-initialized before the next request to ensure that the state is clean and consistent on a per-order basis.

### 3.2 Roles and rationale
- OrderProcessorAgent: robust text extraction with pre-check and retries to reduce misinterpretation and release valid-only BOMs.
- InventoryManagerAgent: operational constraints (stock, min levels, lead times), logically group all sales / stock transactions which can easily be managed together in this scenario.
- QuotingAgent: deterministic pricing to provide the total price on valid BOM only. The quotation is provided to the customer even if the order is not confirmed due to supply delays (the customer may accept the delay as second thought).
- BeaverOrchestrator: enforces step ordering, validation gates, rollback for consistency. Carries out easy, fast and deterministic steps to offload the agents and minimize errors (e.g. extraction of the order date from the customer request which would be available from the system and would not need to be extracted by an agent, generation of the order id, etc.)

## 4) State management (critical)

### 4.1 Where it is defined
- helpers.State dataclass.
- Singleton instance `helpers.state` used across project_starter.py and utils.py.

### 4.2 Key fields and purpose
- `order_counter`, `transaction_counter`: generate sequential IDs.
- `customer_order_id`, `customer_request`, `order_details`: per-request trace.
- `order_date` (extracted from text), `requested_date` (from parsed agent output).
- `availability_date`: list of per-line dates captured during inventory processing.
- `pending_transactions`: tracks every created transaction (for rollback). At customer order level.
- `price_list`, `min_stock_level`: loaded from DB inventory.
- `available_items`: whitelisted SKUs.

### 4.3 Lifecycle per request
- Reset at the top of each iteration in `run_test_scenarios()`:
  - `pending_transactions`, `availability_date`, `customer_order_id`, `requested_date`, `order_date`.
- Update during steps:
  - Append transaction IDs as they are created.
  - Fill availability dates for each BOM line.
  - Maintain counters for `order_id` and `transaction_id`.

Why it matters:
- Enables validation and consistent accounting.
- Allows safe rollback of side effects when feasibility checks fail.
- Clean separation of order timeline: request date vs. delivery date.

## 5) Data models

### 5.1 Dataclass in use
- helpers.State: lightweight, mutable central state. Pros: simple and fast; Cons: no runtime validation.

### 5.2 Pydantic models
I was not able to use for structured ouput of agents (issue with final_response method not allowing or the agent not being able to return a pydantic model). Pydantic models would strengthen validation:

- ParsedOrder
  - `success: bool`
  - `delivery_date: date` (ISO)
  - `comment: Optional[str]`
  - `bill_of_materials: List[ItemQuantity]`
- ItemQuantity
  - `item: Literal[...]` from `state.available_items` (or constrained string)
  - `quantity: PositiveInt`

Benefits:
- Enforces schema for agent outputs.
- Improves error messages for retries.
- Prevents downstream type errors in inventory manager.

## 6) Validation steps and retry loop (OrderProcessorAgent)
Implemented in `BeaverOrchestrator.analyze_request()`:

- Pre-check:
  - `count_order_quantities(text)` robustly counts numbers likely to be quantities:
    - Ignores numbers in dates, decimals, units, and codes like “A4”, “A3”.
    - Supports thousands separators.
- Prompt:
  - Requires enumerated `item:quantity` pairs, `delivery date`, `success`, and `comment` indicating replacement or unavailable items.
- Parse:
  - `parse_agent_response()` extracts fields and retains only allowed items (**the later should be removed, as it likely explains some of the disconnect between the BOM and the naive count in check3, and implemeted just before moving to InventoryManagerAgent**).
- Validate:
  - `check1`: any item not in `state.available_items`.
  - `check2`: number of BOM entries > naive count (double counting).
  - `check3`: number of BOM entries < naive count (missed items).
- Retry loop:
  - Up to 3 attempts; each adds precise error feedback to the processorAgent prompt.
  - Early stop if still failing or `success=False` (the processorAgent determined that the request contains invalid items that BeaverPaper cannot supply).

## 7) Tools and functions (commentary)

From project_starter.py:
- `generate_order_id()`: increments `state.order_counter` to produce `ORD-XXXX`.
- `extract_request_date(text)`: extracts “Date of request: YYYY-MM-DD”.
- `count_order_quantities(text)`: returns `(items count, quantities)` while avoiding false positives.
- `evaluate_purchase_requirement(item_name, quantity_required, input_date_str, db_engine)` :
  - Leverages `create_transaction()`, `get_stock_level()`, `get_supplier_delivery_date()`, `get_cash_balance()`, `generate_financial_report()`:
  - Compares stock vs. need at `input_date_str` (order date).
  - If needed, orders replenishment (`stock_orders`), always creates a `sales` transaction.
  - Updates `state.pending_transactions` and `state.availability_date`.
  - Prints a financial snapshot: `generate_financial_report()` → `pretty_print_financial_report()`.

From utils.py:
- `pretty_print_financial_report(report, version)`.
- `delete_transaction(transaction_id)`: used to rollback when requested delivery is not feasible.
- `parse_agent_response(response, ALLOWED_ITEMS)`: extracts success, order date, delivery date, comment, and valid `item:quantity` pairs.

    These were provided:
- `create_transaction(...)`: inserts into `transactions`. IDs handled via `state.transaction_counter`.
- `get_stock_level(item_name, as_of_date)` and `get_all_inventory(as_of_date)`.
- `get_supplier_delivery_date(input_date_str, quantity)`:
  - Lead times: ≤10 (0d), ≤100 (1d), ≤1000 (4d), >1000 (7d).
- `get_cash_balance(as_of_date)` and `generate_financial_report(as_of_date)`.
- `search_quote_history(search_terms, limit)`.

From helpers.py:
- `db_engine`, `state` initilization functions (shared across modules).

    These were provided:
- `init_database()`: creates schema, seeds `transactions` and `inventory`, sets initial cash.
- `generate_sample_inventory()`: selects a sample with `current_stock` and `min_stock_level`.

**Note that I made a couple corrections to the code of `create_transaction()` and `init_database()` in order to fix the generation of the 'id' column in the database.**

## 8) Evaluation results (test_results.csv)

Observations:
- Many confirmed orders with valid earliest pickup dates information and extracted price totals:
  - Examples: ids 1, 4, 10-11, 13–15, 18 (consistent confirmations showing calculated availability dates in line with requested delivery dates).
- Clear messages for substitutions and failures:
  - Id 12: confirms with substitution (“napkin” → “Paper plates”).
  - Ids 2-3, 5-9, 12, 16-17, 19-20: non-confirmations due to unavailable items which are clearly indicated.
- Financial realism:
  - Cash and inventory evolve as orders progress (later state around 45.3k cash / 4.7k inventory value).

Strengths:
- Guardrails reduce LLM misparsing (pre-check + focused retries).
- Deterministic lead times per line item. could offer scheduling optimizarion potential.
- Transaction logging and rollback preserve consistency.
- Price extraction is robust.
- Pushed deterministic steps to the orchestrator or tools (e.g., order ID generation, date extraction) to reduce LLM error surface.
    - Prefer tool-first routing: if a step can be achieved with a deterministic tool, call it before consulting an agent.

Limitations:
- The system is not able to handle multiple orders at the same time.
- The convention to issue sales uses the order date as the date of the transaction. In the real world we should be using the delivery date as the date of the transaction. This would require to monitor the cash more closely due to working capital effects from delayed payments.

## 9) Improvements and next steps

- Improved definitions of inventory references
  - Improved inventory reference labels with product types, sizes, finishes and grades.
  e.g. "A4 glossy paper" or "A4 printer paper", "recycled kraft paper envelopes"
  - clearer princing for different sizes
  e.g glossy paper has a unique price independent of the size

- Improved parsing of customer orders (most critical point of the workflow)
  - objective: better extraction of paper references (BOM generation)
  - the `parse_agent_response()` function could be modified to allow non existing items, as it likely explains the disconnect between the BOM and the naive count in check3. This safety feature should be removed and re-implemented just before pushing the BOM to InventoryManagerAgent.
  - other possible approaches:
    - keyword matching could be envisaged but would be significantly less flexible with remaining extraction performance issues
    - fine-tuned model or LLM on ER (Entity Recognition) for paper references can be envisaged and could improve extraction performance

- Introduce Pydantic models and structured JSON output
  - Failed to impose structured outputs to agent when using structured JSON could streamline the workflow. Example for OrderProcessorAgent: input contains `customer_request`, `allowed_items`, `naive_item_count`, output contains `success`, `delivery_date`, `comment`, `bill_of_materials`.
  - Add `ParsedOrder` and `BOM` models.
  - Update the prompt to require strict JSON adhering to a schema example.
  - Parse with `json.loads()` and validate with Pydantic before inventory processing.
  - etc...

- Agentic workflow structure
  - Agent definitions
    - combine all verification steps in the OrderProcessorAgent using a reviewer agent to verify the BOM and success flag (is the information valid and complete?) with minimal and precise feedback to the OrderProcessorAgent for retry.
  - Roles and task boundaries
    - separate stock order transactions from sales transaction to allow for clear domain separation and additional capabilities around pricing (discount management, price optimization, early payment discount, etc.) and/or purchasing management (grouping stock order to leverage volume-based purchase discount, etc.)
  - Orchestration pattern
    - Use a clear step function per phase: parse → validate → plan inventory actions → execute transactions → quote → finalize.
  - Parallelism and batching
    - consider calling in parallel the inventory agent and the quotation agent using the available BOM.
    - consider batch processing of order requests (multiple orders at the same time using log of orders)
    - For large BOMs, evaluate inventory feasibility per line in parallel.
    - Batch DB reads (inventory snapshots) at the start of the inventory phase to group I/O.

- Reduce reliance on global state?

- Alternatives/substitution catalog
  - Provide a tool or dictionary of acceptable substitutes (e.g., “standard printing paper” → “80 lb text paper”) and have the parsing step propose/annotate substitutions automatically.

- Transaction integrity hardening
  - Prefer DB autoincrement primary keys instead of managing `id` manually via state for concurrency safety (this would fall into the starter code you provide)

- Richer evaluation and metrics
  - Extend test_results.csv with:
    - Parsed BOM, retry count, feasibility deltas, rollback IDs.
  - Add aggregate KPIs:
    - Confirmation rate, average retries, lead-time deltas, revenue and margin, top unavailable requested items, substitution frequency.

## 11) Screenshots

- sample order
![order](./assets/sample_order.png)

- sample parsed response processorAgentwith BOM
![bom](./assets/sample_bom.png)

- sample inventory Agent response
![inventoryagent](./assets/sample_inventoryagent_response.png)

- sample orchestrator response
![response](./assets/sample_orchestrator_response.png)

- sample orchestrator response with order failure
![response](./assets/sample_fail_success.png)

- sample orchestrator response with order failure
![response](./assets/sample_fail_success_2.png)

## 12) How to run (Windows with UV)
- Prerequisites:
  - Python environment; DB seeds automatically at import (`helpers.init_database()`).
- install and run commands:
    - download project and cd into project folder
    - create virtual env with pip or uv

        - pip: `python -m venv .venv`
        - uv: `uv init`

    - activate virtual env if pip

        - pip: `.venv\Scripts\activate` if windows or `source .venv/bin/activate` if linux

    - install dependencies with pip or uv

        - pip: `pip install -r requirements.txt`
        - uv: `uv add -r requirements.txt`

    - run `uv run python project_starter.py` or `python project_starter.py` (inside your .venv if using pip)